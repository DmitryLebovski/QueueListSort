using System;
using System.Collections.Generic;
using bsbo_011215_22;

internal class Application
{
    static public int N_OP = 0;
    static public int n = 5; // размер сортируемого стэка.

    static void Main(string[] args)
    {
        Queue queue = new Queue();

        // Заполнение очереди n случайными элементами
        Random rnd = new Random();
        for (int i = 0; i < n; i++)
        {
            queue.Enqueue(rnd.Next(0, 100));
        }

        Console.Write("Очередь до сортировки: ");
        queue.Print();

        Console.WriteLine($"Удален элемент: {queue.Dequeue()} ");

        Console.Write("Промежуточный вывод: ");
        queue.Print();

        /* Описание  алгоритма пузырьковой сортировки:
        1. Итерация по очереди: Алгоритм начинает сравнивать пары соседних элементов, начиная с первой пары(индексы 0 и 1) и до последней пары(индексы N-2 и N-1), где N - размер очереди;
        2. Сравнение и перестановка: Для каждой пары элементов сравниваются их значения.Если значение текущего элемента больше значения следующего элемента, они меняются местами;
        3. Подъём наибольшего элемента: В результате первой итерации самый большой элемент "всплывает" к концу очереди (индекс N-1);
        4. Повторение итераций: Процесс повторяется для всех оставшихся элементов, и каждый раз самый большой элемент "всплывает" на одну позицию ближе к концу очереди;
        5. Условие завершения: После каждой итерации проверяется, была ли выполнена перестановка элементов. Если на текущей итерации не было ни одной перестановки, значит очередь уже отсортирована, и сортировка завершается;
        6. Повторение цикла: Если были произведены перестановки, алгоритм повторяет весь процесс итераций до тех пор, пока не будет достигнуто условие завершения(swapFlag = false) */
        // Реализации алгоритма пузырьковой сортировки
        int count = queue.Count;
        bool swapFlag = false; // переменная-флаг, по которой отслеживается факт выполнения перестановки на итерации
        for (int i = 0; i < count - 1; i++)
        {
            swapFlag = false; // сбрасывание флага перестановки
            for (int j = 0; j < count - i - 1; j++)
            {
                if (queue[j] > queue[j + 1])
                {
                    (queue[j], queue[j + 1]) = (queue[j + 1], queue[j]);
                    swapFlag = true;
                }
            }
            // Если на итерации не было перестановок, значит очередь отсортирована, поэтому можно закончить работу цикла
            if (!swapFlag)
                break;
            }

        Console.Write("Очередь после сортировки: ");
        queue.Print();
    }
}

